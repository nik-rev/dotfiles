use simply_colored::*;
use std::env::current_dir;
use std::error::Error;
use std::fs::canonicalize;
use std::io::{self, Write as _};
use std::path::absolute;
use std::{env, fs, path::Path};
use tap::Pipe;

use log::Level;
use walkdir::WalkDir;

fn remove_file(file: &Path) -> Result<(), io::Error> {
    match fs::remove_file(file) {
        Err(err) if err.kind() == std::io::ErrorKind::NotFound => Ok(()),
        Err(err) => Err(err),
        Ok(()) => {
            log::warn!("{RED}removed{RESET} {}", file.display());
            Ok(())
        }
    }
}

fn main() {
    env_logger::Builder::new()
        .filter_level(log::LevelFilter::Info)
        .format(|buf, record| {
            let color = match record.level() {
                Level::Error => RED,
                Level::Warn => YELLOW,
                Level::Info => GREEN,
                Level::Debug => BLUE,
                Level::Trace => CYAN,
            };
            let level = record.level();
            let message = record.args();

            writeln!(buf, "{BLACK}[{color}{level}{BLACK}]{RESET} {message}",)
        })
        .init();

    let home = env::home_dir().unwrap();

    let root = Path::new(env!("CARGO_MANIFEST_DIR")).join("..");
    let root_configs = root.join("configs");

    fn generated_comment(s: &str, url: &str, ext: &str) -> String {
        let header = [
            "@generated by `cargo dotfiles`".to_string(),
            "Do not edit by hand.".to_string(),
            "".to_string(),
            format!("downloaded from: {url}"),
        ];
        header
            .into_iter()
            .fold(String::new(), |contents, line| {
                format!(
                    "{contents}{}",
                    match ext {
                        "nu" | "toml" => format!("# {line}\n"),
                        "ron" => format!("// {line}\n"),
                        "tmTheme" => format!("<!-- {line} -->\n"),
                        _ => line.to_string(),
                    }
                )
            })
            .pipe(|comment| format!("{comment}{s}"))
    }

    [
        (
            concat!(
                "https://raw.githubusercontent.com/catppuccin/nushell/",
                "05987d258cb765a881ee1f2f2b65276c8b379658/themes/catppuccin_mocha.nu",
            ),
            root_configs.join("nushell").join("catppuccin.nu"),
            "d639441cd3b4afe1d05157da64c0564c160ce843182dfe9043f76d56ef2c9cdf",
        ),
        (
            concat!(
                "https://raw.githubusercontent.com/catppuccin/yazi/",
                "1a8c939e47131f2c4bd07a2daea7773c29e2a774/themes/mocha/catppuccin-mocha-blue.toml",
            ),
            root_configs.join("yazi").join("theme.toml"),
            "a9bbdcfab32d1a1cf4d0b34f1cd3ebdb3f30680534a2992dd859936aa2a55bd8",
        ),
        (
            concat!(
                "https://raw.githubusercontent.com/catppuccin/gitui/",
                "df2f59f847e047ff119a105afff49238311b2d36/themes/catppuccin-mocha.ron",
            ),
            root_configs.join("gitui").join("theme.ron"),
            "a2e4a295fb288ee349eadfe88c28f04b68cdc9dbc673b00d13b1851793e4aa3e",
        ),
        (
            concat!(
                "https://raw.githubusercontent.com/catppuccin/bat/",
                "6810349b28055dce54076712fc05fc68da4b8ec0/themes/Catppuccin%20Mocha.tmTheme",
            ),
            root_configs
                .join("bat")
                .join("themes")
                .join("catppuccin.tmTheme"),
            "395566f08ceb301b936b91c077690ef94f7aeb651b121553f201c99c2bd4aa77",
        ),
    ]
    .iter()
    .map(|(url, download_to, expected_sha256)| {
        let contents = ureq::get(*url).call()?.body_mut().read_to_string()?;
        remove_file(download_to).unwrap();
        let actual_sha256 = sha256::digest(&contents);

        if actual_sha256 != *expected_sha256 {
            let mismatch = format!("link       {BLUE}{url}{RESET}");
            let actual = format!("actual     {CYAN}{actual_sha256}{RESET}");
            let expected = format!("expected   {CYAN}{expected_sha256}{RESET}");
            return Err(format!("hash mismatch\n  {mismatch}\n  {actual}\n  {expected}").into());
        };

        fs::create_dir_all(download_to.parent().unwrap()).unwrap();
        fs::write(
            download_to,
            generated_comment(
                &contents,
                url,
                download_to.extension().unwrap().to_str().unwrap(),
            ),
        )
        .unwrap();
        log::info!(
            "{CYAN}downloaded{RESET}\n  {BLUE}{url}{RESET} {BLACK}\n  ->{RESET}  {}",
            download_to.display()
        );

        Ok::<_, Box<dyn Error>>(())
    })
    .partition::<Vec<_>, _>(Result::is_ok)
    .pipe(|(_, errors)| {
        for error in &errors {
            log::error!(
                "{}",
                error
                    .as_ref()
                    .expect_err("can only get here if `Result::is_err`")
            );
        }
        if !errors.is_empty() {
            panic!()
        }
    });

    let current_dir = current_dir().unwrap();

    #[cfg(target_os = "windows")]
    let config = home.join("AppData");
    #[cfg(not(target_os = "windows"))]
    let config = home.join(".config");

    WalkDir::new(&root_configs)
        .into_iter()
        .flatten()
        .filter(|dir_entry| dir_entry.file_type().is_file())
        .for_each(|file| {
            let old_location = file.path();
            let relative_location = old_location.strip_prefix(&root_configs).unwrap();
            let new_location = config.join(relative_location);

            let old_relative_to_cwd_canon = canonicalize(old_location).unwrap();
            let old_relative_to_cwd = old_relative_to_cwd_canon
                .strip_prefix(&current_dir)
                .unwrap()
                .display();

            // 1. Remove the old file
            match fs::remove_file(&new_location) {
                Err(err) if err.kind() == std::io::ErrorKind::NotFound => (),
                Err(err) => {
                    panic!("{err}");
                }
                Ok(()) => {
                    log::warn!("{RED}removed{RESET} {old_relative_to_cwd}");
                }
            }

            // 2. Parent directory of existing file might not exit
            //
            //    We don't want to symlink directories themselves,
            //    because they might contain data we don't want in
            //    our dotfiles.
            fs::create_dir_all(new_location.parent().unwrap()).unwrap();

            let se = absolute(old_location).unwrap();
            let xe = absolute(&new_location).unwrap();

            // 3. Symlink old -> new
            #[cfg(target_os = "windows")]
            std::os::windows::fs::symlink_file(&se, &xe).unwrap();
            #[cfg(not(target_os = "windows"))]
            std::os::unix::fs::symlink(se, &xe).unwrap();

            log::info!(
                "{CYAN}symlinked{RESET} \n  {} {BLACK}\n  ->  {RESET}~{}{}",
                old_relative_to_cwd,
                std::path::MAIN_SEPARATOR,
                new_location.strip_prefix(&home).unwrap().display()
            );
        })
}
