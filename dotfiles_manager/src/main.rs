use clap::Parser;
use etcetera::BaseStrategy;
use handlebars::Handlebars;
use interpolator::Formattable;
use serde::{Deserialize, Serialize};
use simply_colored::*;
use std::collections::{BTreeMap, HashMap};
use std::env::current_dir;
use std::error::Error;
use std::fs::canonicalize;
use std::io::{self, Write as _};
use std::path::PathBuf;
use std::{env, fs, path::Path};
use tap::Pipe;

use log::Level;
use walkdir::WalkDir;

#[derive(Serialize, Deserialize)]
struct Config {
    config_dir: PathBuf,
    links: Vec<Link>,
}

#[derive(Serialize, Deserialize)]
struct Link {
    url: String,
    path: PathBuf,
    sha256: Option<String>,
}

fn remove_file(file: &Path) -> Result<(), io::Error> {
    match fs::remove_file(file) {
        Err(err) if err.kind() == std::io::ErrorKind::NotFound => Ok(()),
        Err(err) => Err(err),
        Ok(()) => {
            log::warn!("{RED}removed{RESET} {}", file.display());
            Ok(())
        }
    }
}

fn main() {
    env_logger::Builder::new()
        .filter_level(log::LevelFilter::Info)
        .format(|buf, record| {
            let color = match record.level() {
                Level::Error => RED,
                Level::Warn => YELLOW,
                Level::Info => GREEN,
                Level::Debug => BLUE,
                Level::Trace => CYAN,
            };
            let level = record.level();
            let message = record.args();

            writeln!(buf, "{BLACK}[{color}{level}{BLACK}]{RESET} {message}",)
        })
        .init();

    let root = current_dir().unwrap();
    let config = root
        .join("dotfiles.toml")
        .pipe(fs::read_to_string)
        .unwrap()
        .pipe(|x| toml::de::from_str::<Config>(&x))
        .unwrap();

    let home = env::home_dir().unwrap();

    let root_configs = root.join(config.config_dir);

    fn generated_comment(s: &str, url: &str, ext: &str) -> String {
        let header = [
            "@generated by `cargo dotfiles`".to_string(),
            "Do not edit by hand.".to_string(),
            "".to_string(),
            format!("downloaded from: {url}"),
        ];
        header
            .into_iter()
            .fold(String::new(), |contents, line| {
                format!(
                    "{contents}{}",
                    match ext {
                        "nu" | "toml" => format!("# {line}\n"),
                        "ron" => format!("// {line}\n"),
                        "tmTheme" => format!("<!-- {line} -->\n"),
                        _ => line.to_string(),
                    }
                )
            })
            .pipe(|comment| format!("{comment}{s}"))
    }

    config
        .links
        .iter()
        .map(|Link { url, path, sha256 }| {
            let contents = ureq::get(url).call()?.body_mut().read_to_string()?;
            let path = root_configs.join(path);
            remove_file(&path).unwrap();
            let actual_sha256 = sha256::digest(&contents);

            if let Some(sha256) = sha256
                && actual_sha256 != *sha256
            {
                let mismatch = format!("link       {BLUE}{url}{RESET}");
                let actual = format!("actual     {CYAN}{actual_sha256}{RESET}");
                let expected = format!("expected   {CYAN}{sha256}{RESET}");
                return Err(
                    format!("hash mismatch\n  {mismatch}\n  {actual}\n  {expected}").into(),
                );
            };

            fs::create_dir_all(path.parent().unwrap()).unwrap();
            fs::write(
                &path,
                generated_comment(&contents, url, path.extension().unwrap().to_str().unwrap()),
            )
            .unwrap();
            log::info!(
                "{CYAN}downloaded{RESET}\n  {BLUE}{url}{RESET} {BLACK}\n  ->{RESET}  {}",
                path.display()
            );

            Ok::<_, Box<dyn Error>>(())
        })
        .partition::<Vec<_>, _>(Result::is_ok)
        .pipe(|(_, errors)| {
            for error in &errors {
                log::error!(
                    "{}",
                    error
                        .as_ref()
                        .expect_err("can only get here if `Result::is_err`")
                );
            }
            if !errors.is_empty() {
                panic!()
            }
        });

    #[cfg(target_os = "windows")]
    let config = home.join("AppData");
    #[cfg(not(target_os = "windows"))]
    let config = home.join(".config");

    WalkDir::new(&root_configs)
        .into_iter()
        .flatten()
        .filter(|dir_entry| dir_entry.file_type().is_file())
        .for_each(|file| {
            let old_location = file.path();

            let file_contents = fs::read_to_string(old_location).unwrap();

            #[derive(Parser)]
            struct MarkerArgs {
                path: String,
            }

            let strat = etcetera::choose_base_strategy().unwrap();

            let marker = "@dotfilers ";
            let relative_location = old_location.strip_prefix(&root_configs).unwrap();

            let new_location = if let Some(first_line) = file_contents.lines().next()
                && let Some(marker_start_pos) = first_line.find(marker)
                && let Some(marker_args) = first_line.get(marker_start_pos + marker.len()..)
            {
                let args = shellwords::split(marker_args)
                    .unwrap()
                    .pipe(MarkerArgs::try_parse_from)
                    .unwrap();
                interpolator::format(
                    &args.path,
                    &HashMap::from([
                        (
                            "config",
                            strat
                                .config_dir()
                                .to_string_lossy()
                                .to_string()
                                .pipe_ref(Formattable::display),
                        ),
                        (
                            "home",
                            strat
                                .home_dir()
                                .to_string_lossy()
                                .to_string()
                                .pipe_ref(Formattable::display),
                        ),
                    ]),
                )
                .unwrap()
                .pipe(PathBuf::from)
            } else {
                config.join(relative_location)
            };

            let old_relative_to_cwd_canon = canonicalize(old_location).unwrap();
            let old_relative_to_cwd = old_relative_to_cwd_canon
                .strip_prefix(&root)
                .unwrap()
                .display();

            // 1. Remove the old file
            match fs::remove_file(&new_location) {
                Err(err) if err.kind() == std::io::ErrorKind::NotFound => (),
                Err(err) => {
                    panic!("{err}");
                }
                Ok(()) => {
                    log::warn!("{RED}removed{RESET} {old_relative_to_cwd}");
                }
            }

            // 2. Parent directory of existing file might not exit
            //
            //    We don't want to symlink directories themselves,
            //    because they might contain data we don't want in
            //    our dotfiles.
            fs::create_dir_all(new_location.parent().unwrap()).unwrap();

            let mut handlebars = Handlebars::new();
            handlebars
                .register_template_string("t1", file_contents)
                .unwrap();

            let contents = handlebars.render("t1", &BTreeMap::<u8, u8>::new()).unwrap();

            fs::write(&new_location, contents).unwrap();

            log::info!(
                "{CYAN}symlinked{RESET} \n  {} {BLACK}\n  ->  {RESET}{}",
                old_relative_to_cwd,
                new_location
                    .strip_prefix(&home)
                    .map_or(new_location.to_path_buf(), |location| format!(
                        "~{}{}",
                        std::path::MAIN_SEPARATOR,
                        location.display()
                    )
                    .pipe(PathBuf::from))
                    .display()
            );
        })
}
